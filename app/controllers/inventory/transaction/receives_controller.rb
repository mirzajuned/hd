class Inventory::Transaction::ReceivesController < ApplicationController
  include Inventory::ItemsHelper
  before_action :authorize, :verify_store

  def index
    @store_id = params[:store_id]
    @inventory_store = Inventory::Store.find_by(id: params[:store_id])
    @start_date = params[:start_date]
    @end_date = params[:end_date]
    @time_period = params[:time_period]
    @receive_status = ['Pending', 'Cancelled', 'Partially Received', 'Received','All']
    @status = params[:status]
    fetch_transactions
  end

  def append_index
    @store_id = params[:store_id]
    @start_date = params[:start_date]
    @end_date = params[:end_date]
    fetch_transactions
  end

  def filter_index
    @store_id = params[:store_id]
    @start_date = params[:start_date]
    @end_date = params[:end_date]
    @search_by = params[:search_by]
    fetch_transactions
  end

  def show
    @receive = Inventory::Transaction::Receive.find_by(id: params[:id])
    @transfer = Inventory::Transaction::Transfer.find_by(id: @receive.transfer_id)
  end

  def edit
    @receive = Inventory::Transaction::Receive.find_by(id: params[:id])
    @transfer = Inventory::Transaction::Transfer.find_by(id: @receive.transfer_id)
    @sub_stores = Inventory::SubStore.where(store_id: @receive.store_id, is_deleted: false).pluck(:name, :id)
  end

  def update
    @receive, @transfer = Inventory::Transactions::Receive::UpdateService
                          .call(params[:id], current_user.id.to_s, received_items)
  end

  def new
    @store_id = params[:store_id]
    @inventory_store = Inventory::Store.find_by(id: @store_id)
    @category = 'all_item'
    @variants = Inventory::Item::Variant.where(store_id: @store_id).is_active.limit(30)
    @receive_transaction = Inventory::Transaction::Receive.new
  end

  def add_lot
    @variant = Inventory::Item::Variant.find_by(id: params[:variant_id])
    @item = Inventory::Item.find_by(id: @variant.item_id)
    @receive_transaction = Inventory::Transaction::Receive.build(receive_item_params)
    @receive_transaction.items
  end

  def create
    @store_id = params[:inventory_transaction_receive][:store_id]
    @start_date = @end_date = params[:inventory_transaction_receive][:transaction_date]
    @receive_transaction = Inventory::Transaction::Receive.new(receive_transaction_params)
    if @receive_transaction.save!
      InventoryJobs::Transactions::ReceiveJob.perform_later(@receive_transaction.id.to_s, current_user.id.to_s)
    end
    fetch_transactions
  end

  def append_variants
    @store_id = params[:store_id]
    @category = params[:item_type]
    fetch_variant_index
  end

  def filter_variants
    @store_id = params[:store_id]
    @category = params[:item_type]
    fetch_variant_index
  end

  def filter_receive
    @store_id = params[:store_id]
    @department_id = params[:department_id]
  end

  def report
    options = { :facility_ids.in => [current_facility.id], is_active: true }
    @all_user = User.where(options.merge(:inventory_store_ids.in => [params[:store_id]])).pluck(:fullname, :id)
    @start_date = params[:start_date]
    @end_date = params[:end_date]
    @inventory_store = Inventory::Store.find(params[:store_id])
  end

  def download_data
    store = Inventory::Store.find(params[:store_id])
    options = { store_id: params[:store_id], start_date: Time.parse(params['start_date'] + ' ' + params['start_time']),
                end_date: Time.parse(params['end_date'] + ' ' + params['end_time']), user: params[:user_id] }
    user = params[:user_id] == 'all_user' ? 'all_user' : User.find(params[:user_id]).fullname
    @store_name = "#{store.name} Receive Report"
    @address = store.address
    @time_period = "Detailed Receive Report For a Period of #{params[:start_date]} #{params[:start_time]} to #{params[:end_date]} #{params[:end_time]}"
    @generate_on = "Generated On: #{Time.now.try(:strftime, '%R:%S')} | #{Time.now.strftime('%d %B %Y')} | #{Date.today.strftime('%A')}"
    @generate_by = "Generated By: #{user&.titleize}"
    @filename = "#{store.name.squish&.titleize&.tr(' ', '_')}_#{Time.now.strftime('%d %B %Y')}_#{Time.now.try(:strftime, '%R:%S')}_#{user.squish&.titleize&.tr(' ', '_')}_receive_report"
    @data_array, @grand_total = Inventory::Transactions::DownloadReceiveService.call(options, params[:department_id], params[:received_by])
    respond_to do |format|
      format.html
      format.xlsx { headers['Content-Disposition'] = "attachment; filename=\"#{@filename}.xlsx\"" }
    end
  end

  def filter_item
    @lot_unit_ids = params[:lot_unit_ids]&.split(',').flatten
    @lot_units = Inventory::Item::LotUnit.where(:id.in => @lot_unit_ids)
    @selected_lot_unit_ids = params[:selected_lot_unit_ids]&.split(',')&.flatten || []
  end

  def lot_unit_item
    @received_lot_units = params[:selected_lot_unit_ids] || []
    @lot_unit_ids = params[:lot_unit_ids] || []
    @rejected_lot_units_ids = @lot_unit_ids - @received_lot_units
    @lot_unit_ids = params[:lot_unit_ids]
  end

  private

  def receive_transaction_params
    # params.require(:inventory_transaction_receive).permit!
    params.require(:inventory_transaction_receive)
          .permit(
            :note, :vendor_id, :transaction_date, :vendor_name, :entry_type, :entered_by, :user_id, :store_id,
            :total_cost, :facility_id, :organisation_id,
            items_attributes: [
              { custom_field_data: {} }, { custom_field_tags: [] }, :item_code, :default_variant_code, :item_id,
              :default_variant_id, :category, :barcode, :barcode_present, :reference_id, :variant_identifier, :_destroy,
              :search, :mark_up, :batch_no, :cost_price, :total_cost_price, :stock_package, :stock_subpackage,
              :stock_unit, :stock_free_unit, :stock, :mrp_pack, :mrp, :list_price_pack, :list_price, :tax_inclusive,
              :tax_rate, :tax_name, :tax_group_id, :mrp_pack_denomination, :list_price_pack_denomination, :self_batched,
              :expiry, :expiry_present, :total_cost, :unit_cost, :description, :store_id, :facility_id,
              :organisation_id, :unit_non_taxable_amount, :unit_taxable_amount, { lot_unit_ids: [] },
              { rejected_lot_unit_ids: [] }, { received_lot_unit_ids: [] }
            ]
          )
  end

  def receive_item_params
    params.require(:item).permit! # We are not saving these params on this steps, hence permitted all params.
  end

  def received_items
    params.require(:inventory_transaction_receive)
          .permit(:id, :total_cost, items_attributes: [:transfer_item_id, :stock, :total_cost, :sub_store_id,
                                                       :sub_store_name, :rejected_stock, :not_received_comment,
                                                       { rejected_lot_unit_ids: [] }, { received_lot_unit_ids: [] }])
  end

  def fetch_transactions
    current_data_row = params[:total_count_row].to_i
    query = params[:q].to_s
    if (@search_by == "Requisition Id")
      options = { store_id: @store_id, "requisition_display_id": /#{query}/i, is_deleted: false }
    elsif (@search_by == "Item Name")
      options = { store_id: @store_id, "items.description": /#{Regexp.escape(query)}/i, is_deleted: false }
    else
      options = { store_id: @store_id, transfer_note: /#{Regexp.escape(query)}/i, is_deleted: false }
    end
    options = options.merge(status: @status) if @status.present? && @status != "All"
    options[:transfer_date] = { :$gte => @start_date, :$lte => @end_date } if @start_date.present? && @end_date.present?
    @receives = Inventory::Transaction::Receive.where(options).order_by(created_at: 'desc').skip(current_data_row)
                                               .limit(30)
  end
end
